// Consider a modification to merge sort in which n/k sublists of length k are sorted using insertion sort.
// then merge using the standard merging mechanism, where k is a value to be determined
//
//
// input [1,11,5,2,9,12,8,10];
// output [1.2.5,11.8,9,10,12];
//

// n = length of array
// k = sublist

const std = @import("std");

//fn integerSortSublist(A: []i32, n: u32, k: u32) void {
    // var sl = n / k;
//}

fn insertionSort(A: []i32, start: u32, end: u32) void {
    while (start < end) : (start += 1) {
        const key: i32 = A[@intCast(start + 1)];
        while (start >= 0 and A[@intCast(start)] > key) : (start -= 1) {
            A[@intCast(start + 1)] = key;
        }
        A[@intCast(start + 1)] = key;
    }
}

test "insertion sort" {
    var numbers = [_]i32{ 9, 2, 3, 5, 1, 12, 8, 10 };
    const len: usize = numbers.len;
    integerSortSublist(numbers[0..], len, 4);
    std.debug.print("{any}\n", .{numbers});
}
